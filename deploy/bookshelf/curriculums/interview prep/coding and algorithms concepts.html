<!DOCTYPE html>
<html>
    <head>
        <title>dupe.sh</title>
        <link rel="stylesheet"
            href="https://dupe.sh/static/css/main.css">
        <!-- <script src="https://kit.fontawesome.com/0387a22d91.js" crossorigin="anonymous"></script> -->
        <link href="https://unpkg.com/mono-icons@1.3.1/iconfont/icons.css" rel="stylesheet">
    </head>
<body>
    <div class="post">

    <div class="nav-bar">
        <span class="nav-list">
            <a href="https://dupe.sh/index.html">~/</a>
        </span>
    </div>

    <h1>coding and algorithms concepts.html</h1>

    <div class="post-metadata">
        

        
    </div>


    

    <div class="post-content">
        <ul>
<li>Data Structures
<ul>
<li>Arrays</li>
<li>Vectors</li>
<li>Maps/Hash tables</li>
<li>Strings</li>
<li>Linked Lists</li>
<li>Stacks
<ul>
<li>Monotonic stack</li>
</ul></li>
<li>Queues
<ul>
<li>priority queues</li>
</ul></li>
<li>Trees</li>
<li>Graphs</li>
<li>Tries</li>
<li>Heaps</li>
</ul></li>
<li>Algorithms &amp; Concepts
<ul>
<li>Bit manipulation</li>
<li>Math</li>
<li>Object oriented design</li>
<li>Sliding windows</li>
<li>Two pointers</li>
<li>Slow &amp; fast pointers</li>
<li>Prefix sum</li>
<li>Recursion
<ul>
<li>Recursive backtracking</li>
</ul></li>
<li>Dynamic programming</li>
<li>Greedy algorithms</li>
<li>Sorting
<ul>
<li>Merge sort</li>
<li>Quick sort</li>
</ul></li>
<li>Tree traversal
<ul>
<li>In order</li>
<li>Post order</li>
<li>Pre order</li>
</ul></li>
<li>Searching
<ul>
<li>BFS</li>
<li>DFS</li>
<li>Binary search</li>
</ul></li>
<li>Memory structure (stack vs. heap)</li>
<li>Big O (time &amp; space complexity)</li>
</ul></li>
<li>Testing
<ol type="1">
<li>Conceptual - run through code like code review</li>
<li>Unusual - test cases for any unusual or complex code</li>
<li>Hotspots - test cases for most important/expensive logic</li>
<li>General - 0, 1, many input cases</li>
<li>Special &amp; edge cases</li>
</ol></li>
</ul>
<h1 id="techniques">techniques</h1>
<p>⭐ := need to practice</p>
<h2 id="general">general</h2>
<ul>
<li>don’t be afraid to break a solution down into discrete cases; i.e.,
sometimes better to have several separate loops through data to
represent different problem stages/states instead of cramming all logic
into one consolidated loop.</li>
</ul>
<h2 id="arrays">arrays</h2>
<ol type="1">
<li>sliding window</li>
<li>two pointers</li>
<li>traversing from the right</li>
<li>sort the array
<ol type="1">
<li>is the array already sorted? if so, we can exploit that</li>
<li>may simplify the problem to sort the array if it is given
unsorted</li>
</ol></li>
<li>precomputation ⭐
<ol type="1">
<li>e.g. computing prefix sums</li>
</ol></li>
<li>index as hash key ⭐</li>
<li>traverse the array multiple times</li>
</ol>
<h2 id="strings">strings</h2>
<p>Ask about character sets and case sensitivity; e.g., problem may be
limited to lower case Latin letters (a to z).</p>
<h5 id="counting-characters">counting characters</h5>
<p>In Python, this can be done using the <code>Counter</code> class</p>
<h5 id="compute-what-characters-are-present-in-a-string">compute what
characters are present in a string</h5>
<pre><code>mask = 0
for c in word:
    mask |= (1 &lt;&lt; (ord(c) - ord(&#39;a&#39;)))</code></pre>
<p>you can then check if two strings have the common characters then
with <code>maskA &amp; maskB &gt; 0</code></p>
<h5 id="anagram-check">anagram check</h5>
<ol type="1">
<li><p>map each character to a prime number and multiply them together.
prime number decomposition. this gives identifiers that can be
compared.</p></li>
<li><p>frequency counts of characters also produces O(n) solutions ##
heaps</p></li>
<li><p>mentions of “top/bottom k”</p></li>
</ol>
<h2 id="dynamic-programming">dynamic programming</h2>
<ul>
<li><p>three components of a dp problem: (1) some function or array
representing the problem answer at a given state, (2) a transition
between states (recurrence relation), and (3) base cases</p></li>
<li><p>don’t be afraid of iterating over subproblems; e.g., in longest
increasing subsequence, need to consider <em>all</em> numbers before the
current index i if adding i to their subsequences is valid</p></li>
<li><p>think about subproblems that either START at the target index, or
END at the target index. ENDING seems more common; e.g., dp[i] is the
longest increasing subsequence ENDING at index i</p></li>
<li><p>sometimes you don’t need to store the whole <code>dp</code>
matrix in memory. keeping only the “last X” subproblems needed to
compute the current might suffice.</p></li>
<li><p>also possible that multiple passes are necessary to compute
optimal solution; e.g., for paths through a matrix visiting adjacent
cells, one pass to calculate paths moving “left and up,” another for
“right and down.” Example:</p></li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Problem: given a matrix of 0s and 1s, find the shortest</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    path from all 1s to their nearest 0s</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> updateMatrix(<span class="va">self</span>, mat: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [row[:] <span class="cf">for</span> row <span class="kw">in</span> mat]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> <span class="bu">len</span>(dp)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(dp[<span class="dv">0</span>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># all paths starting top-left and traversing down &amp; left</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dp[row][col] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                    min_n <span class="op">=</span> inf</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> row <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row<span class="op">-</span><span class="dv">1</span>][col])</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> col <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row][col <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                    dp[row][col] <span class="op">=</span> min_n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># all paths starting bottom-right and traversing top &amp; left</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dp[row][col] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                    min_n <span class="op">=</span> inf</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> row <span class="op">&lt;</span> m <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row <span class="op">+</span> <span class="dv">1</span>][col])</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> col <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row][col <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                    dp[row][col] <span class="op">=</span> <span class="bu">min</span>(dp[row][col], min_n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp</span></code></pre></div>
<h2 id="bfsdfs">bfs/dfs</h2>
<ul>
<li><p>when you think of shortest path problems through a graph, you
should think of BFS.</p></li>
<li><p>sometimes good to have <em>multiple</em> starting nodes; e.g.,
all nodes with value 0 in a matrix</p></li>
</ul>
<h2 id="quickselect">quickselect</h2>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> kClosest(<span class="va">self</span>, points: List[List[<span class="bu">int</span>]], k: <span class="bu">int</span>) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.quick_select(points, k)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> euclidean(<span class="va">self</span>, point):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> point[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> point[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> choose_pivot(<span class="va">self</span>, points, left, right):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> points[left <span class="op">+</span> (right <span class="op">-</span> left) <span class="op">//</span> <span class="dv">2</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> partition(<span class="va">self</span>, points, left, right):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> <span class="va">self</span>.choose_pivot(points, left, right)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        pivot_d <span class="op">=</span> <span class="va">self</span>.euclidean(pivot)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> left <span class="op">&lt;</span> right:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.euclidean(points[left]) <span class="op">&gt;=</span> pivot_d:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                points[left], points[right] <span class="op">=</span> points[right], points[left]</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                right <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                left <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.euclidean(points[left]) <span class="op">&lt;</span> pivot_d:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            left <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> left</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> quick_select(<span class="va">self</span>, points, k):</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> <span class="bu">len</span>(points) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pivot <span class="op">!=</span> k:</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            pivot <span class="op">=</span> <span class="va">self</span>.partition(points, left, right)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pivot <span class="op">&lt;</span> k:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>                left <span class="op">=</span> pivot</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>                right <span class="op">=</span> pivot <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> points[:k]</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<h2 id="sorting-algorithms">sorting algorithms</h2>
<h3 id="counting-sort">counting sort</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_sort(A, k):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: list of integers to be sorted</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    k: upper bound of range of integers in A: [0, k-1]</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k)]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> A:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        counts[key] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(l, k):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># compute the _indices_ in output that</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># each key will be assigned</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        counts[i] <span class="op">+=</span> counts[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate through A _reversed_; this ensures stability,</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># since elements that appear later in A with the same</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># key will be placed in later indices of the output</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> <span class="bu">reversed</span>(A):</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        output[counts[key] <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> key</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        counts[key] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div>
<h3 id="radix-sort">radix sort</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> radix_sort(A, d, k):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: list of keys to be sorted</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    d: number of digits in each k</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    k: upper bound of integers in A&#39;s digits: [0, k-1]</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through digits from least to most significant</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> digit <span class="kw">in</span> <span class="bu">range</span>(d <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        stable_sort(A, k, digit) <span class="co"># typically count_sort</span></span></code></pre></div>
<h3 id="bucket-sort">bucket sort</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bucket_sort(A):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: array with all keys in distribution [0, 1)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    num_buckets <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    buckets <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_buckets)]  </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># distribute keys to their assigned bucket</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> A:</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        buckets[<span class="bu">int</span>(num_buckets<span class="op">*</span>key)].append(key)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sort the keys within each bucket</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bucket <span class="kw">in</span> buckets:</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        insertion_sort(bucket)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [x <span class="cf">for</span> bucket <span class="kw">in</span> buckets <span class="cf">for</span> x <span class="kw">in</span> bucket]</span></code></pre></div>
<h2 id="topological-sort">topological sort</h2>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> topological_sort(graph: <span class="bu">dict</span>[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]]) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">int</span>]:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    in_count <span class="op">=</span> {i: <span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph.keys()))}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edges <span class="kw">in</span> graph.values():</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> edges:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            in_count[node] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> []</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> graph:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> in_count[node] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            queue.append(node)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        next_queue <span class="op">=</span> []</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> queue:</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            result.append(node)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            end_nodes <span class="op">=</span> graph[node]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> end_node <span class="kw">in</span> end_nodes:</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                in_count[end_node] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> in_count[end_node] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                    next_queue.append(end_node)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        queue <span class="op">=</span> next_queue</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<h2 id="monotonic-stack">monotonic stack</h2>
<p>A monotonic stack is a stack that maintains an additional invariant
on its elements: they are all in either increasing or decreasing order
(relative to some criterion) based on their arrival time.</p>
<p>The “Trapping Water” problem is a good application of monotonic
stacks. In the following solution, we maintain a stack of decreasing
heights, representing the possible “left sides” of trenches/holes in
which water can be “trapped.” As soon as we hit a height that is greater
than the top of the stack, we have found the “right side” of a water
trapping trench, and process it.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> trap(<span class="va">self</span>, height: List[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># maintain monotonic stack, as soon as elevation &gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># top of stack, we have &quot;trapped&quot; and process</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> []</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> current <span class="op">&lt;</span> <span class="bu">len</span>(height):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> stack <span class="kw">and</span> height[current] <span class="op">&gt;</span> height[stack[<span class="op">-</span><span class="dv">1</span>]]:</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                trapped_bottom <span class="op">=</span> stack.pop()</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> stack:</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>                distance <span class="op">=</span> current <span class="op">-</span> stack[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>                trapped_height <span class="op">=</span> <span class="bu">min</span>(height[current], height[stack[<span class="op">-</span><span class="dv">1</span>]]) <span class="op">-</span> height[trapped_bottom]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>                result <span class="op">+=</span> distance <span class="op">*</span> trapped_height</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            stack.append(current)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            current <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span></code></pre></div>
<h2 id="binary-search">binary search</h2>
<h3 id="searching-in-rotated-sorted-array">searching in rotated sorted
array</h3>
<p>I think the key insight in this question is the fact we can modify
the form of a standard binary search to leverage new properties of the
data as given, or to search for a match beyond the default criteria of
“some target.”</p>
<p>For reference, here’s is an implementation of canonical binary
search</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search(nums, target):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> start <span class="op">&lt;=</span> end:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> start <span class="op">+</span> (end <span class="op">-</span> start) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[mid] <span class="op">==</span> target:</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[mid] <span class="op">&gt;</span> target:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<h4 id="leveraging-new-properties-of-the-data">leveraging new properties
of the data</h4>
<p>Given a sorted array whose elements have been rotated by some amount
k, we derive the following property at each step of the canonical binary
search:</p>
<p>After partitioning the array at the search point <code>mid</code>, we
have two subarrays: the subarray to the left of <code>mid</code> and the
one to the right. One of these two subarrays is guaranteed to be
sorted.</p>
<p>We can thus tweak canonical binary search to consider this fact. At
each step, we determine which subarray is sorted by comparing the
elements at its boundaries. Then we can decide whether we should search
within the sorted subarray by check if our target lies within its
bounds. Elegant.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, nums: List[<span class="bu">int</span>], target: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> start <span class="op">&lt;=</span> end:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            mid <span class="op">=</span> start <span class="op">+</span> (end <span class="op">-</span> start) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nums[mid] <span class="op">==</span> target:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> mid</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> nums[mid] <span class="op">&gt;=</span> nums[start]:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                <span class="co"># left subarray is sorted</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> target <span class="op">&gt;=</span> nums[start] <span class="kw">and</span> target <span class="op">&lt;</span> nums[mid]:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># target is guaranteed to be in left subarray</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># if present at all</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                    end <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># target is not to the left, try right</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                    start <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                <span class="co"># right subarray is the sorted array</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> target <span class="op">&lt;=</span> nums[end] <span class="kw">and</span> target <span class="op">&gt;</span> nums[mid]:</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>                    start <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>                    end <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<h4 id="searching-for-elements-beyond-target-criteria">searching for
elements beyond “target” criteria</h4>
<p>Another approach to this problem can be derived by recognizing that
pivoting at the “rotation index” gives us two separate sorted arrays we
can search through. The rotation index is the index of the smallest
element in the array. How do we find it? Through binary search,
comparing the current midpoint to the <em>last element of the
array</em>. If the current midpoint is <em>greater</em> than the last
element, then the smallest element must be to its right. If it is
smaller, then either it is the smallest element or the smaller element
is to its left.</p>
<p>This gives us the following binary search implementation. Note that
we may “pass” the smallest element in the middle of the algorithm. If
mid IS the smallest element at any point, then we will search to its
left. That search will then continuously update <code>left</code> until
it <em>equals</em> the lowest element, because all elements to its left
are actually greater than the smallest element and thus greater than the
last element of the array.</p>
<p>That explanation properly isn’t all too clear… I’ll have to rewrite
that.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search_smallest_element(nums):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&lt;=</span> right:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> (left <span class="op">+</span> right) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[mid] <span class="op">&gt;</span> nums[<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> left</span></code></pre></div>

    </div>

    

</div>


</body>
</html>
