<!DOCTYPE html>
<html>
    <head>
        <title>dupe.sh</title>
        <link rel="stylesheet"
            href="https://dupe.sh/static/css/main.css">
        <!-- <script src="https://kit.fontawesome.com/0387a22d91.js" crossorigin="anonymous"></script> -->
        <link href="https://unpkg.com/mono-icons@1.3.1/iconfont/icons.css" rel="stylesheet">
    </head>
<body>
    <div class="post">

    <div class="nav-bar">
        <span class="nav-list">
            <a href="https://dupe.sh/index.html">~/</a>
        </span>
    </div>

    <h1>coding and algorithms concepts.html</h1>

    <div class="post-metadata">
        

        
    </div>


    

    <div class="post-content">
        <ul>
<li>Data Structures
<ul>
<li>Arrays</li>
<li>Vectors</li>
<li>Maps/Hash tables</li>
<li>Strings</li>
<li>Linked Lists</li>
<li>Stacks
<ul>
<li>Monotonic stack</li>
</ul></li>
<li>Queues
<ul>
<li>priority queues</li>
</ul></li>
<li>Trees</li>
<li>Graphs</li>
<li>Tries</li>
<li>Heaps</li>
</ul></li>
<li>Algorithms &amp; Concepts
<ul>
<li>Bit manipulation</li>
<li>Math</li>
<li>Object oriented design</li>
<li>Sliding windows</li>
<li>Two pointers</li>
<li>Slow &amp; fast pointers</li>
<li>Prefix sum</li>
<li>Recursion
<ul>
<li>Recursive backtracking</li>
</ul></li>
<li>Dynamic programming</li>
<li>Greedy algorithms</li>
<li>Sorting
<ul>
<li>Merge sort</li>
<li>Quick sort</li>
</ul></li>
<li>Tree traversal
<ul>
<li>In order</li>
<li>Post order</li>
<li>Pre order</li>
</ul></li>
<li>Searching
<ul>
<li>BFS</li>
<li>DFS</li>
<li>Binary search</li>
</ul></li>
<li>Memory structure (stack vs. heap)</li>
<li>Big O (time &amp; space complexity)</li>
</ul></li>
<li>Testing
<ol type="1">
<li>Conceptual - run through code like code review</li>
<li>Unusual - test cases for any unusual or complex code</li>
<li>Hotspots - test cases for most important/expensive logic</li>
<li>General - 0, 1, many input cases</li>
<li>Special &amp; edge cases</li>
</ol></li>
</ul>
<h1 id="techniques">techniques</h1>
<p>⭐ := need to practice</p>
<h2 id="arrays">arrays</h2>
<ol type="1">
<li>sliding window</li>
<li>two pointers</li>
<li>traversing from the right</li>
<li>sort the array
<ol type="1">
<li>is the array already sorted? if so, we can exploit that</li>
<li>may simplify the problem to sort the array if it is given
unsorted</li>
</ol></li>
<li>precomputation ⭐
<ol type="1">
<li>e.g. computing prefix sums</li>
</ol></li>
<li>index as hash key ⭐</li>
<li>traverse the array multiple times</li>
</ol>
<h2 id="strings">strings</h2>
<p>Ask about character sets and case sensitivity; e.g., problem may be
limited to lower case Latin letters (a to z).</p>
<h5 id="counting-characters">counting characters</h5>
<p>In Python, this can be done using the <code>Counter</code> class</p>
<h5 id="compute-what-characters-are-present-in-a-string">compute what
characters are present in a string</h5>
<pre><code>mask = 0
for c in word:
    mask |= (1 &lt;&lt; (ord(c) - ord(&#39;a&#39;)))</code></pre>
<p>you can then check if two strings have the common characters then
with <code>maskA &amp; maskB &gt; 0</code></p>
<h5 id="anagram-check">anagram check</h5>
<ol type="1">
<li><p>map each character to a prime number and multiply them together.
prime number decomposition. this gives identifiers that can be
compared.</p></li>
<li><p>frequency counts of characters also produces O(n) solutions ##
heaps</p></li>
<li><p>mentions of “top/bottom k”</p></li>
</ol>
<h2 id="dynamic-programming">dynamic programming</h2>
<ul>
<li><p>three components of a dp problem: (1) some function or array
representing the problem answer at a given state, (2) a transition
between states (recurrence relation), and (3) base cases</p></li>
<li><p>don’t be afraid of iterating over subproblems; e.g., in longest
increasing subsequence, need to consider <em>all</em> numbers before the
current index i if adding i to their subsequences is valid</p></li>
<li><p>think about subproblems that either START at the target index, or
END at the target index. ENDING seems more common; e.g., dp[i] is the
longest increasing subsequence ENDING at index i</p></li>
<li><p>sometimes you don’t need to store the whole <code>dp</code>
matrix in memory. keeping only the “last X” subproblems needed to
compute the current might suffice.</p></li>
</ul>
<h2 id="sorting-algorithms">sorting algorithms</h2>
<h3 id="counting-sort">counting sort</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_sort(A, k):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: list of integers to be sorted</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    k: upper bound of range of integers in A: [0, k-1]</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k)]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> A:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        counts[key] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(l, k):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># compute the _indices_ in output that</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># each key will be assigned</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        counts[i] <span class="op">+=</span> counts[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate through A _reversed_; this ensures stability,</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># since elements that appear later in A with the same</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># key will be placed in later indices of the output</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> <span class="bu">reversed</span>(A):</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        output[counts[key] <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> key</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        counts[key] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div>
<h3 id="radix-sort">radix sort</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> radix_sort(A, d, k):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: list of keys to be sorted</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    d: number of digits in each k</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    k: upper bound of integers in A&#39;s digits: [0, k-1]</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through digits from least to most significant</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> digit <span class="kw">in</span> <span class="bu">range</span>(d <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        stable_sort(A, k, digit) <span class="co"># typically count_sort</span></span></code></pre></div>
<h3 id="bucket-sort">bucket sort</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bucket_sort(A):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: array with all keys in distribution [0, 1)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    num_buckets <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    buckets <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_buckets)]  </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># distribute keys to their assigned bucket</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> A:</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        buckets[<span class="bu">int</span>(num_buckets<span class="op">*</span>key)].append(key)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sort the keys within each bucket</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bucket <span class="kw">in</span> buckets:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        insertion_sort(bucket)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [x <span class="cf">for</span> bucket <span class="kw">in</span> buckets <span class="cf">for</span> x <span class="kw">in</span> bucket]</span></code></pre></div>
<h2 id="topological-sort">topological sort</h2>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> topological_sort(graph: <span class="bu">dict</span>[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]]) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">int</span>]:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    in_count <span class="op">=</span> {i: <span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph.keys()))}</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edges <span class="kw">in</span> graph.values():</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> edges:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            in_count[node] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> []</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> graph:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> in_count[node] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            queue.append(node)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        next_queue <span class="op">=</span> []</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> queue:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            result.append(node)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            end_nodes <span class="op">=</span> graph[node]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> end_node <span class="kw">in</span> end_nodes:</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>                in_count[end_node] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> in_count[end_node] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>                    next_queue.append(end_node)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        queue <span class="op">=</span> next_queue</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>

    </div>

    

</div>


</body>
</html>
