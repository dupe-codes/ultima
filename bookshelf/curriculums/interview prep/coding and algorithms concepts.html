<!DOCTYPE html>
<html>
    <head>
        <title>dupe.sh</title>
        <link rel="stylesheet"
            href="https://dupe.sh/static/css/main.css">
        <!-- <script src="https://kit.fontawesome.com/0387a22d91.js" crossorigin="anonymous"></script> -->
        <link href="https://unpkg.com/mono-icons@1.3.1/iconfont/icons.css" rel="stylesheet">
    </head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<body>
    <div class="post">

    <div class="nav-bar">
        <span class="nav-list">
            <a href="https://dupe.sh/index.html">~/</a>
        </span>
    </div>

    <h1>coding and algorithms concepts.html</h1>

    <div class="post-metadata">
        

        
    </div>


    

    <div class="post-content">
        <ul>
<li>Data Structures
<ul>
<li>Arrays</li>
<li>Vectors</li>
<li>Maps/Hash tables</li>
<li>Strings</li>
<li>Linked Lists</li>
<li>Stacks
<ul>
<li>Monotonic stack</li>
</ul></li>
<li>Queues
<ul>
<li>priority queues</li>
</ul></li>
<li>Trees</li>
<li>Graphs</li>
<li>Tries</li>
<li>Heaps</li>
</ul></li>
<li>Algorithms &amp; Concepts
<ul>
<li>Bit manipulation</li>
<li>Math</li>
<li>Object oriented design</li>
<li>Sliding windows</li>
<li>Two pointers</li>
<li>Slow &amp; fast pointers</li>
<li>Prefix sum</li>
<li>Recursion
<ul>
<li>Recursive backtracking</li>
</ul></li>
<li>Dynamic programming</li>
<li>Greedy algorithms</li>
<li>Sorting
<ul>
<li>Merge sort</li>
<li>Quick sort</li>
</ul></li>
<li>Tree traversal
<ul>
<li>In order</li>
<li>Post order</li>
<li>Pre order</li>
</ul></li>
<li>Searching
<ul>
<li>BFS</li>
<li>DFS</li>
<li>Binary search</li>
</ul></li>
<li>Memory structure (stack vs. heap)</li>
<li>Big O (time &amp; space complexity)</li>
</ul></li>
<li>Testing
<ol type="1">
<li>Conceptual - run through code like code review</li>
<li>Unusual - test cases for any unusual or complex code</li>
<li>Hotspots - test cases for most important/expensive logic</li>
<li>General - 0, 1, many input cases</li>
<li>Special &amp; edge cases</li>
</ol></li>
</ul>
<h1 id="techniques">techniques</h1>
<p>⭐ := need to practice</p>
<h2 id="general">general</h2>
<ul>
<li>don’t be afraid to break a solution down into discrete cases; i.e.,
sometimes better to have several separate loops through data to
represent different problem stages/states instead of cramming all logic
into one consolidated loop.</li>
</ul>
<h2 id="arrays">arrays</h2>
<ol type="1">
<li>sliding window</li>
<li>two pointers</li>
<li>traversing from the right</li>
<li>sort the array
<ol type="1">
<li>is the array already sorted? if so, we can exploit that</li>
<li>may simplify the problem to sort the array if it is given
unsorted</li>
</ol></li>
<li>precomputation ⭐
<ol type="1">
<li>e.g. computing prefix sums</li>
</ol></li>
<li>index as hash key ⭐</li>
<li>traverse the array multiple times</li>
</ol>
<h2 id="strings">strings</h2>
<p>Ask about character sets and case sensitivity; e.g., problem may be
limited to lower case Latin letters (a to z).</p>
<h5 id="counting-characters">counting characters</h5>
<p>In Python, this can be done using the <code>Counter</code> class</p>
<h5 id="compute-what-characters-are-present-in-a-string">compute what
characters are present in a string</h5>
<pre><code>mask = 0
for c in word:
    mask |= (1 &lt;&lt; (ord(c) - ord(&#39;a&#39;)))</code></pre>
<p>you can then check if two strings have the common characters then
with <code>maskA &amp; maskB &gt; 0</code></p>
<h5 id="anagram-check">anagram check</h5>
<ol type="1">
<li><p>map each character to a prime number and multiply them together.
prime number decomposition. this gives identifiers that can be
compared.</p></li>
<li><p>frequency counts of characters also produces O(n) solutions ##
heaps</p></li>
<li><p>mentions of “top/bottom k”</p></li>
</ol>
<h2 id="dynamic-programming">dynamic programming</h2>
<ul>
<li><p>three components of a dp problem: (1) some function or array
representing the problem answer at a given state, (2) a transition
between states (recurrence relation), and (3) base cases</p></li>
<li><p>don’t be afraid of iterating over subproblems; e.g., in longest
increasing subsequence, need to consider <em>all</em> numbers before the
current index i if adding i to their subsequences is valid</p></li>
<li><p>think about subproblems that either START at the target index, or
END at the target index. ENDING seems more common; e.g., dp[i] is the
longest increasing subsequence ENDING at index i</p></li>
<li><p>sometimes you don’t need to store the whole <code>dp</code>
matrix in memory. keeping only the “last X” subproblems needed to
compute the current might suffice.</p></li>
<li><p>also possible that multiple passes are necessary to compute
optimal solution; e.g., for paths through a matrix visiting adjacent
cells, one pass to calculate paths moving “left and up,” another for
“right and down.” Example:</p></li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Problem: given a matrix of 0s and 1s, find the shortest</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    path from all 1s to their nearest 0s</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> updateMatrix(<span class="va">self</span>, mat: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [row[:] <span class="cf">for</span> row <span class="kw">in</span> mat]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> <span class="bu">len</span>(dp)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(dp[<span class="dv">0</span>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># all paths starting top-left and traversing down &amp; left</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dp[row][col] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                    min_n <span class="op">=</span> inf</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> row <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row<span class="op">-</span><span class="dv">1</span>][col])</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> col <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row][col <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                    dp[row][col] <span class="op">=</span> min_n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># all paths starting bottom-right and traversing top &amp; left</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dp[row][col] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                    min_n <span class="op">=</span> inf</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> row <span class="op">&lt;</span> m <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row <span class="op">+</span> <span class="dv">1</span>][col])</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> col <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                        min_n <span class="op">=</span> <span class="bu">min</span>(min_n, dp[row][col <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                    dp[row][col] <span class="op">=</span> <span class="bu">min</span>(dp[row][col], min_n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp</span></code></pre></div>
<h3 id="max-profit-job-scheduling">max profit job scheduling</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Job:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, start, end, profit):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start <span class="op">=</span> start</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.end <span class="op">=</span> end</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.profit <span class="op">=</span> profit</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__lt__</span>(<span class="va">self</span>, other):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.start <span class="op">&lt;</span> other.start</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f&quot;Job(start: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>start<span class="sc">}</span><span class="ss">, end: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>end<span class="sc">}</span><span class="ss">, profit: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>profit<span class="sc">}</span><span class="ss">)&quot;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="fu">__repr__</span>()</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> jobScheduling(<span class="va">self</span>, startTime: List[<span class="bu">int</span>], endTime: List[<span class="bu">int</span>], profit: List[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        jobs <span class="op">=</span> [Job(startTime[i], endTime[i], profit[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(startTime))]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        jobs.sort()</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        start_times <span class="op">=</span> [job.start <span class="cf">for</span> job <span class="kw">in</span> jobs]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(startTime))]</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(jobs) <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>            next_schedulable_job <span class="op">=</span> bisect_left(start_times, jobs[i].end)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            next_profit <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> next_schedulable_job <span class="op">==</span> <span class="bu">len</span>(jobs) <span class="cf">else</span> dp[next_schedulable_job]</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            profit <span class="op">=</span> jobs[i].profit <span class="op">+</span> next_profit</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="bu">len</span>(jobs) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> profit</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(profit, dp[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[<span class="dv">0</span>]</span></code></pre></div>
<h2 id="identifying-graph-problems">identifying graph problems</h2>
<ul>
<li>big hints
<ul>
<li>problem presentation with <em>elements</em> that are
<em>connected</em>. <strong>connectivity</strong></li>
<li>problems that describe finding the shortest distance (think
<em>path</em>) between elements</li>
<li>anything involving <em>states</em> and <em>transitions</em> between
them</li>
<li>anything that describes <em>dependencies</em> between elements</li>
</ul></li>
</ul>
<h4 id="account-merging">account merging</h4>
<p>Whenever we must work with a set of elements (emails) that are
connected (belong to the same user), we should always consider
visualizing our input as a graph</p>
<h2 id="bfsdfs">bfs/dfs</h2>
<ul>
<li><p>when you think of shortest path problems through a graph, you
should think of BFS.</p></li>
<li><p>sometimes good to have <em>multiple</em> starting nodes; e.g.,
all nodes with value 0 in a matrix</p></li>
<li><p>if you need to process a tree level-by-level, think BFS. A good
example is the <a
href="https://leetcode.com/problems/binary-tree-right-side-view/editorial/">Binary
Tree Right Side View</a> problem. It’s possible to solve with DFS, but
the solution is trickier. With a BFS approach, we can confidently “find”
the right most element of each level to “view” by processing the BFS
queue; the last element inserted into the queue for a level is the
element we “view!”</p></li>
</ul>
<h2 id="quickselect">quickselect</h2>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> kClosest(<span class="va">self</span>, points: List[List[<span class="bu">int</span>]], k: <span class="bu">int</span>) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.quick_select(points, k)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> euclidean(<span class="va">self</span>, point):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> point[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> point[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> choose_pivot(<span class="va">self</span>, points, left, right):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> points[left <span class="op">+</span> (right <span class="op">-</span> left) <span class="op">//</span> <span class="dv">2</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> partition(<span class="va">self</span>, points, left, right):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> <span class="va">self</span>.choose_pivot(points, left, right)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        pivot_d <span class="op">=</span> <span class="va">self</span>.euclidean(pivot)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> left <span class="op">&lt;</span> right:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.euclidean(points[left]) <span class="op">&gt;=</span> pivot_d:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                points[left], points[right] <span class="op">=</span> points[right], points[left]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                right <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                left <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.euclidean(points[left]) <span class="op">&lt;</span> pivot_d:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            left <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> left</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> quick_select(<span class="va">self</span>, points, k):</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> <span class="bu">len</span>(points) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pivot <span class="op">!=</span> k:</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>            pivot <span class="op">=</span> <span class="va">self</span>.partition(points, left, right)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pivot <span class="op">&lt;</span> k:</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                left <span class="op">=</span> pivot</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>                right <span class="op">=</span> pivot <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> points[:k]</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<h2 id="sorting-algorithms">sorting algorithms</h2>
<h3 id="counting-sort">counting sort</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_sort(A, k):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: list of integers to be sorted</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    k: upper bound of range of integers in A: [0, k-1]</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k)]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> A:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        counts[key] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(l, k):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># compute the _indices_ in output that</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># each key will be assigned</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        counts[i] <span class="op">+=</span> counts[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate through A _reversed_; this ensures stability,</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># since elements that appear later in A with the same</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># key will be placed in later indices of the output</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> <span class="bu">reversed</span>(A):</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        output[counts[key] <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> key</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        counts[key] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div>
<h3 id="radix-sort">radix sort</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> radix_sort(A, d, k):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: list of keys to be sorted</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    d: number of digits in each k</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    k: upper bound of integers in A&#39;s digits: [0, k-1]</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through digits from least to most significant</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> digit <span class="kw">in</span> <span class="bu">range</span>(d <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        stable_sort(A, k, digit) <span class="co"># typically count_sort</span></span></code></pre></div>
<h3 id="bucket-sort">bucket sort</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bucket_sort(A):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A: array with all keys in distribution [0, 1)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    num_buckets <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    buckets <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_buckets)]  </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># distribute keys to their assigned bucket</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> A:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        buckets[<span class="bu">int</span>(num_buckets<span class="op">*</span>key)].append(key)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sort the keys within each bucket</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bucket <span class="kw">in</span> buckets:</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        insertion_sort(bucket)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [x <span class="cf">for</span> bucket <span class="kw">in</span> buckets <span class="cf">for</span> x <span class="kw">in</span> bucket]</span></code></pre></div>
<h2 id="topological-sort">topological sort</h2>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> topological_sort(graph: <span class="bu">dict</span>[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]]) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">int</span>]:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    in_count <span class="op">=</span> {i: <span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph.keys()))}</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edges <span class="kw">in</span> graph.values():</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> edges:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            in_count[node] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> []</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> graph:</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> in_count[node] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            queue.append(node)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        next_queue <span class="op">=</span> []</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> queue:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            result.append(node)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            end_nodes <span class="op">=</span> graph[node]</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> end_node <span class="kw">in</span> end_nodes:</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>                in_count[end_node] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> in_count[end_node] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                    next_queue.append(end_node)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        queue <span class="op">=</span> next_queue</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<h2 id="monotonic-stack">monotonic stack</h2>
<p>A monotonic stack is a stack that maintains an additional invariant
on its elements: they are all in either increasing or decreasing order
(relative to some criterion) based on their arrival time.</p>
<p>The “Trapping Water” problem is a good application of monotonic
stacks. In the following solution, we maintain a stack of decreasing
heights, representing the possible “left sides” of trenches/holes in
which water can be “trapped.” As soon as we hit a height that is greater
than the top of the stack, we have found the “right side” of a water
trapping trench, and process it.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> trap(<span class="va">self</span>, height: List[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># maintain monotonic stack, as soon as elevation &gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># top of stack, we have &quot;trapped&quot; and process</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> []</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> current <span class="op">&lt;</span> <span class="bu">len</span>(height):</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> stack <span class="kw">and</span> height[current] <span class="op">&gt;</span> height[stack[<span class="op">-</span><span class="dv">1</span>]]:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                trapped_bottom <span class="op">=</span> stack.pop()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> stack:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                distance <span class="op">=</span> current <span class="op">-</span> stack[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                trapped_height <span class="op">=</span> <span class="bu">min</span>(height[current], height[stack[<span class="op">-</span><span class="dv">1</span>]]) <span class="op">-</span> height[trapped_bottom]</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                result <span class="op">+=</span> distance <span class="op">*</span> trapped_height</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            stack.append(current)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            current <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span></code></pre></div>
<h2 id="binary-search">binary search</h2>
<h3 id="searching-in-rotated-sorted-array">searching in rotated sorted
array</h3>
<p>I think the key insight in this question is the fact we can modify
the form of a standard binary search to leverage new properties of the
data as given, or to search for a match beyond the default criteria of
“some target.”</p>
<p>For reference, here’s is an implementation of canonical binary
search</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search(nums, target):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> start <span class="op">&lt;=</span> end:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> start <span class="op">+</span> (end <span class="op">-</span> start) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[mid] <span class="op">==</span> target:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[mid] <span class="op">&gt;</span> target:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<h4 id="leveraging-new-properties-of-the-data">leveraging new properties
of the data</h4>
<p>Given a sorted array whose elements have been rotated by some amount
k, we derive the following property at each step of the canonical binary
search:</p>
<p>After partitioning the array at the search point <code>mid</code>, we
have two subarrays: the subarray to the left of <code>mid</code> and the
one to the right. One of these two subarrays is guaranteed to be
sorted.</p>
<p>We can thus tweak canonical binary search to consider this fact. At
each step, we determine which subarray is sorted by comparing the
elements at its boundaries. Then we can decide whether we should search
within the sorted subarray by checking if our target lies within those
bounds. Elegant.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, nums: List[<span class="bu">int</span>], target: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> start <span class="op">&lt;=</span> end:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            mid <span class="op">=</span> start <span class="op">+</span> (end <span class="op">-</span> start) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nums[mid] <span class="op">==</span> target:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> mid</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> nums[mid] <span class="op">&gt;=</span> nums[start]:</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                <span class="co"># left subarray is sorted</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> target <span class="op">&gt;=</span> nums[start] <span class="kw">and</span> target <span class="op">&lt;</span> nums[mid]:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># target is guaranteed to be in left subarray</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># if present at all</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>                    end <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># target is not to the left, try right</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                    start <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                <span class="co"># right subarray is the sorted array</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> target <span class="op">&lt;=</span> nums[end] <span class="kw">and</span> target <span class="op">&gt;</span> nums[mid]:</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>                    start <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>                    end <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<h4 id="searching-for-elements-beyond-target-criteria">searching for
elements beyond “target” criteria</h4>
<p>Another approach to this problem can be derived by recognizing that
pivoting at the “rotation index” gives us two separate sorted arrays we
can search through. The rotation index is the index of the smallest
element in the array. How do we find it? Through binary search,
comparing the current midpoint to the <em>last element of the
array</em>. If the current midpoint is <em>greater</em> than the last
element, then the smallest element must be to its right. If it is
smaller, then either it is the smallest element or the smaller element
is to its left.</p>
<p>This gives us the following binary search implementation. Note that
we may “pass” the smallest element in the middle of the algorithm. If
mid IS the smallest element at any point, then we will search to its
left. That search will then continuously update <code>left</code> until
it <em>equals</em> the lowest element, because all elements to its left
are actually greater than the smallest element and thus greater than the
last element of the array.</p>
<p>That explanation properly isn’t all too clear… I’ll have to rewrite
that.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search_smallest_element(nums):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&lt;=</span> right:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> (left <span class="op">+</span> right) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[mid] <span class="op">&gt;</span> nums[<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> left</span></code></pre></div>
<h3 id="searching-for-closest-element-to-target">searching for closest
element to target</h3>
<p>How about searching a sorted list for the <em>closest</em> element to
the target such that <code>element &lt;= target</code>?</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search_closest(values, target):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> <span class="bu">len</span>(values)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&lt;</span> right:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> left <span class="op">+</span> (right <span class="op">-</span> left) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> values[mid] <span class="op">&lt;=</span> target:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> mid</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span> <span class="cf">if</span> right <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> values[right <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<p>One way to think of this: it will lift <code>left</code> up until it
points just beyond the last element &lt;= the target, and then whittle
right down until it is equal to <code>left</code>; thus, the closest
element is one before <code>right</code>, or isn’t present if
<code>right</code> points to the start of the list.</p>
<h2 id="calculator-questions">“calculator” questions</h2>
<p>quite the troublesome instantiation of a parse and apply logic
problem…</p>
<p>prompt: implement a basic calculator that handles the operators
+,-,*,/</p>
<pre><code>class Solution:
    def calculate(self, s: str) -&gt; int:
        def evaluate(operator, x, y = 0):
            if operator == &quot;+&quot;:
                return x
            if operator == &quot;-&quot;:
                return -x
            if operator == &quot;*&quot;:
                return x * y
            return int(x / y)
        
        stack = []
        curr = 0
        previous_operator = &quot;+&quot;
        s += &quot;@&quot;
        
        for c in s:
            if c == &quot; &quot;:
                continue
            if c.isdigit():
                curr = curr * 10 + int(c)
            else:
                if previous_operator in &quot;*/&quot;:
                    stack.append(evaluate(previous_operator, stack.pop(), curr))
                else:
                    stack.append(evaluate(previous_operator, curr))
                
                curr = 0
                previous_operator = c

        return sum(stack)</code></pre>

    </div>

    

</div>


</body>
</html>
